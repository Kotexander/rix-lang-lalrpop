use crate::ast::Expr;
use crate::ast::BinOp;
use crate::ast::UniOp;
use crate::ast::Item;
use crate::ast::Instr;
use crate::lexer::Tok;
use lalrpop_util::ParseError;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = String;

    enum Tok<'input> {
        fn => Tok::Fn,
        return => Tok::Return,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Asterisk,
        "/" => Tok::Slash,
        "&" => Tok::And,
        "," => Tok::Comma,
        "\n" => Tok::NewLine,
        id => Tok::Id(<&'input str>),
        number => Tok::Number(<&'input str>),
        string => Tok::String(<&'input str>),
    }
}

pub Program = NewLines<Item>;

Item: Item = {
    fn <Id> "(" ")" "{" ("\n")* <(<Instr> "\n"+)*> "}" => Item::Function(<>),
}
Instr: Instr = {
    return <Expr?>  => Instr::Return(<>),
    <Id> "(" <Exprs> ")" => Instr::Call(<>),
}

Tier<Op, NextTier> = {
    Tier<Op, NextTier> Op NextTier => Expr::bin_op(<>),
    NextTier,
}

Expr = Tier<BinOpExpr, Factor>;
Exprs: Vec<Expr> = Comma<Expr>;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};
NewLines<T>: Vec<T> = {
    <mut v:(<T> "\n"+)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};


Factor = Tier<BinOpFactor, Term>;

// pub Expr = {
//     Expr ExprOp Factor => Expr::bin_op(<>),
//     Factor,
// }
//
// Factor = {
//     Factor FactorOp Term => Expr::bin_op(<>),
//     Term,
// }

Term: Expr = {
    Num => Expr::Number(<>),
    UniOp Term => Expr::uni_op(<>),
    "(" <Expr> ")",
    Id => Expr::Variable(<>),
    string => Expr::String(<>.to_string()),
}

Num: i32 = {
    number =>? <>.parse::<i32>().map_err(|e| ParseError::User {
            error: e.to_string(),
        })
}
Id: String = {
    id => <>.to_owned()
}

BinOpFactor: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
}
BinOpExpr: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
}
UniOp: UniOp = {
    "-" => UniOp::Neg,
    "&" => UniOp::Ref,
    "*" => UniOp::Deref,
}
