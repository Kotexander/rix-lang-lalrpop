use crate::ast::Expr;
use crate::ast::BinOp;
use crate::ast::UniOp;
use crate::ast::Item;
use crate::ast::Instr;
use crate::lexer::Tok;
use lalrpop_util::ParseError;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = String;

    enum Tok<'input> {
        "fn" => Tok::Fn,
        "return" => Tok::Return,
        "var" => Tok::Var,
        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Asterisk,
        "/" => Tok::Slash,
        "&" => Tok::And,
        "," => Tok::Comma,
        "=" => Tok::Equal,
        "\n" => Tok::NewLine,
        id => Tok::Id(<&'input str>),
        number => Tok::Number(<&'input str>),
        string => Tok::String(<&'input str>),
    }
}

pub Program = SeperatedList<Item, "\n"+>;

Item: Item = {
    "fn" <Id> "(" ")" "{" ("\n")* <(<Instr> "\n"+)*> "}" => Item::Function(<>),
}
Instr: Instr = {
    "return" <Expr?>  => Instr::Return(<>),
    "var" <Id> "=" <Expr> => Instr::VarInit(<>),
    <Expr> => Instr::Expr(<>),
}

Tier<Op, NextTier> = {
    Tier<Op, NextTier> Op NextTier => Expr::bin_op(<>),
    NextTier,
}

Expr = Tier<BinOpExpr, Factor>;
Exprs: Vec<Expr> = SeperatedList<Expr, ",">;

SeperatedList<T, Sep>: Vec<T> = {
    <mut v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Factor = Tier<BinOpFactor, Term>;

Term: Expr = {
    Num => Expr::Number(<>),
    UniOp Term => Expr::uni_op(<>),
    <Id> "(" <Exprs> ")" => Expr::Call(<>),
    "(" <Expr> ")",
    Id => Expr::Variable(<>),
    string => Expr::String(<>.to_string()),
}

Num: i32 = {
    number =>? <>.parse::<i32>().map_err(|e| ParseError::User {
            error: e.to_string(),
        })
}
Id: String = {
    id => <>.to_owned()
}

BinOpFactor: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
}
BinOpExpr: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
}
UniOp: UniOp = {
    "-" => UniOp::Neg,
    "&" => UniOp::Ref,
    "*" => UniOp::Deref,
}
