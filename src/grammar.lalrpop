use crate::ast::AstBuilder;
use crate::ast::Ident;
use crate::ast::Node;

use crate::ast::ItemKind;
use crate::ast::Item;

use crate::ast::InstrKind;
use crate::ast::Instr;

use crate::ast::ExprKind;
use crate::ast::Expr;

use crate::ast::TypKind;
use crate::ast::Typ;
use crate::ast::ArgTypKind;
use crate::ast::ArgTyp;

use crate::ast::BinOp;
use crate::ast::UniOp;

use crate::lexer::Tok;
use crate::lexer;
use lalrpop_util::ParseError;
use lalrpop_util::ErrorRecovery;

grammar<'input, 'err>(input: &'input str,
                      builder: &mut AstBuilder,
                      errors: &'err mut Vec<ErrorRecovery<usize, Tok<'input>, lexer::Error>>);

extern {
    type Location = usize;
    type Error = lexer::Error;

    enum Tok<'input> {
        "fn" => Tok::Fn,
        "return" => Tok::Return,
        "var" => Tok::Var,
        "for" => Tok::For,
        "while" => Tok::While,
        "break" => Tok::Break,
        "continue" => Tok::Continue,
        "in" => Tok::In,
        "if" => Tok::If,
        "else" => Tok::Else,
        "struct" => Tok::Struct,
        "union" => Tok::Union,

        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        "[" => Tok::LBracket,
        "]" => Tok::RBracket,

        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Asterisk,
        "/" => Tok::Slash,
        "&" => Tok::Apersand,
        "%" => Tok::Percent,
        "!" => Tok::Not,
        "." => Tok::Dot,
        ".." => Tok::DotDot,
        "..." => Tok::DotDotDot,
        "," => Tok::Comma,
        "=" => Tok::Equal,
        "<" => Tok::LessThan,
        ">" => Tok::GreaterThan,
        "<=" => Tok::LessEqual,
        ">=" => Tok::GreaterEqual,
        "==" => Tok::EqualEqual,
        "!=" => Tok::NotEqual,
        "=>" => Tok::EqualGreater,
        "and" => Tok::And,
        "or" => Tok::Or,
        "\n" => Tok::NewLine,
        ":" => Tok::Colon,
        id => Tok::Ident(<&'input str>),
        number => Tok::Number(<&'input str>),
        string => Tok::String(<usize>, <&'input str>),
    }
}

pub Program = ("\n")* <SeperatedList<Item, "\n"+>>;

Item: Item = Node<ItemKind>;
ItemKind: ItemKind = {
    "fn" <name: Ident> "(" <args: SeperatedList<Arg, ",">> ")" <ret: (":" <Typ>)?> <body: (Block)?> => ItemKind::Function{<>},
    "struct" <name: Ident> "{" "\n"+ <fields: SeperatedList<Field, "\n"+>> "}" => ItemKind::Struct{<>},
    "union" <name: Ident> "{" "\n"+ <variants: SeperatedList<Field, "\n"+>> "}" => ItemKind::Union{<>},
    // ! => {errors.push(<>); Item::Error},
}

ArgTyp: ArgTyp = Node<ArgTypKind>;
ArgTypKind: ArgTypKind = {
    Typ => ArgTypKind::Typ(<>),
    "..." => ArgTypKind::VarArgs,
}
Arg = <Ident> ":" <ArgTyp>;
Field = <Ident> ":" <Typ>;

Typ: Typ = Node<TypKind>;
TypKind: TypKind = {
    Ident => TypKind::Ident(<>),
    "&" <Box<Typ>> => TypKind::Ref(<>),
    "[" <Box<Typ>> "]" => TypKind::Slice(<>),
    "*" <Box<Typ>> => TypKind::Ptr(<>),
}

Instr: Instr = Node<InstrKind>;
InstrKind: InstrKind = {
    "return" <Expr?> => InstrKind::Return(<>),
    "var" <name: Ident> <typ: TypeHint?> "=" <expr: Expr> => InstrKind::VarInit{<>},
    <name: Ident> "=" <expr: Expr> => InstrKind::VarAssign{<>},
    // "for" <var: Ident> "in" "(" <start: Expr> ".." <end: Expr> ")" <body: Block> => InstrKind::For{<>},
    "while" "(" <cond: Expr> ")" <body: Block> => InstrKind::While{<>},
    "break" => InstrKind::Break,
    "continue" => InstrKind::Continue,
    "if" "(" <cond: Expr> ")" <then: Block> <elifs: ("else" "if" "(" <Expr> ")" <Block>)*> <els: ("else" <Block>)?> => InstrKind::If{<>},
    <Expr> => InstrKind::Expr(<>),
    ! => {errors.push(<>); InstrKind::Error}
}
Block: Vec<Instr> = {
    "{" ("\n")+ <(<Instr> "\n"+)*> "}" => <>
}
TypeHint: Typ = {
    ":" <typ: Typ> => typ
}

Exprs: Vec<Expr> = SeperatedList<Expr, ",">;

Expr: Expr = Node<ExprKind>;
ExprKind = Tier<BinOpBoolean,       // lowest precedence
           Tier<BinOpComparison,
           Tier<BinOpExpr,
           Tier<BinOpFactor, Term   // highest precedence
           >>>>;

Term: ExprKind = {
    Num => ExprKind::Number(<>),
    <op: UniOp> <expr: Box<Node<Term>>> => ExprKind::UniOp{<>},
    <name: Ident> "(" <args: Exprs> ")" => ExprKind::Call{<>},
    Ident => ExprKind::Variable(<>),
    <l:@L> <s:string> <r:@R> =>? {
        let parsed_str = lexer::parse_string_literal(s.1,s.0,l..r)
                    .map_err(|e| ParseError::User { error: e })?;
        let id = builder.interner.intern(&parsed_str);

        Ok(ExprKind::String(id))
    },
    "(" <expr: Box<Node<Term>>> "." <field: Ident> ")" => ExprKind::FieldAccess{<>},
    "(" <ExprKind> ")" => <>,
    <name: Ident> "{" <fields: SeperatedList<FieldInit, ",">> "}" => ExprKind::StructInit{<>},
    // ! => {errors.push(<>); ExprKind::Error},
}
FieldInit: (Ident, Expr) = {
    "." <name: Ident> "=" <value: Expr> => (name, value)
}

Num: i32 = {
    <l:@L> <n: number> <r:@R> =>? {
        lexer::parse_number(n, l..r).map_err(|e| ParseError::User { error: e })
    }
}
Ident: Ident = {
    <l:@L> <s:id> <r:@R> => Ident::new(l, builder.interner.intern(s), r, builder.node_id_gen.next_id())
}

BinOpFactor: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
}
BinOpExpr: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
}
BinOpBoolean: BinOp = {
    "and" => BinOp::And,
    "or" => BinOp::Or,
}
BinOpComparison: BinOp = {
    "==" => BinOp::Eq,
    "<" => BinOp::Lt,
    ">" => BinOp::Gt,
    "<=" => BinOp::Le,
    ">=" => BinOp::Ge,
    "!=" => BinOp::Ne,
}
UniOp: UniOp = {
    "-" => UniOp::Neg,
    "&" => UniOp::Ref,
    "*" => UniOp::Deref,
    // "!" => UniOp::Not,
}

SeperatedList<T, Sep>: Vec<T> = {
    <mut v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Tier<Op, NextTier>: ExprKind = {
    <l:Box<Node<Tier<Op, NextTier>>>> <op:Op> <r:Box<Node<NextTier>>> => ExprKind::BinOp{<>},
    NextTier,
}

Node<T>: Node<T> = {
    <@L> <T> <@R> => Node::new(<>, builder.node_id_gen.next_id()),
}

Box<T>: Box<T> = <T> => Box::new(<>);
