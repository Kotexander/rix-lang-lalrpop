use crate::ast::ExprKind;
use crate::ast::Expr;
use crate::ast::BinOp;
use crate::ast::UniOp;
use crate::ast::Item;
use crate::ast::InstrKind;
use crate::ast::Instr;
use crate::lexer::Tok;
use lalrpop_util::ParseError;
use lalrpop_util::ErrorRecovery;

grammar<'input, 'err>(input: &'input str,
                      errors: &'err mut Vec<ErrorRecovery<usize, Tok<'input>, String>>);

extern {
    type Location = usize;
    type Error = String;

    enum Tok<'input> {
        "fn" => Tok::Fn,
        "return" => Tok::Return,
        "var" => Tok::Var,
        "for" => Tok::For,
        "in" => Tok::In,
        "if" => Tok::If,
        "else" => Tok::Else,

        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Asterisk,
        "/" => Tok::Slash,
        "&" => Tok::Apersand,
        "%" => Tok::Percent,
        "." => Tok::Dot,
        ".." => Tok::DotDot,
        "," => Tok::Comma,
        "=" => Tok::Equal,
        "==" => Tok::EqualEqual,
        "and" => Tok::And,
        "\n" => Tok::NewLine,
        id => Tok::Id(<&'input str>),
        number => Tok::Number(<&'input str>),
        string => Tok::String(<&'input str>),
    }
}

pub Program = ("\n")* <SeperatedList<Item, "\n"+>>;

Item: Item = {
    "fn" <Id> "(" ")" <Block> => Item::Function(<>),
    // ! => {errors.push(<>); Item::Error},
}

Instr: Instr = SpannedInstr<InstrKind>;
InstrKind: InstrKind = {
    "return" <Expr?> => InstrKind::Return(<>),
    "var" <name: Id> "=" <expr: Expr> => InstrKind::VarInit{<>},
    "for" <var: Id> "in" <start: Expr> ".." <end: Expr> <body: Block> => InstrKind::For{<>},
    "if" <cond: Expr> <then: Block> <elifs: ("else" "if" <Expr> <Block>)*> <els: ("else" <Block>)?> => InstrKind::If{<>},
    <Expr> => InstrKind::Expr(<>),
    ! => {errors.push(<>); InstrKind::Error}
}
Block: Vec<Instr> = {
    "{" ("\n")+ <(<Instr> "\n"+)*> "}" => <>
}

Exprs: Vec<Expr> = SeperatedList<Expr, ",">;

Expr = SpannedExpr<ExprKind>;
ExprKind = Tier<BinOpBoolean,       // lowest precedence
           Tier<BinOpComparison,
           Tier<BinOpExpr,
           Tier<BinOpFactor, Term   // highest precedence
           >>>>;

Term: ExprKind = {
    Num => ExprKind::Number(<>),
    <op: UniOp> <expr: Box<SpannedExpr<Term>>> => ExprKind::UniOp{<>},
    <name: Id> "(" <args: Exprs> ")" => ExprKind::Call{<>},
    Id => ExprKind::Variable(<>),
    string => ExprKind::String(<>.to_string()),
    "(" <ExprKind> ")" => <>,
    // ! => {errors.push(<>); ExprKind::Error},
}

Num: i32 = {
    number =>? <>.parse::<i32>().map_err(|e| ParseError::User {
            error: e.to_string(),
        })
}
Id: String = {
    id => <>.to_owned()
}

BinOpFactor: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
}
BinOpExpr: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
}
BinOpBoolean: BinOp = {
    "and" => BinOp::And,
}
BinOpComparison: BinOp = {
    "==" => BinOp::Eq,
}
UniOp: UniOp = {
    "-" => UniOp::Neg,
    "&" => UniOp::Ref,
    "*" => UniOp::Deref,
}

SeperatedList<T, Sep>: Vec<T> = {
    <mut v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Tier<Op, NextTier>: ExprKind = {
    <l:Box<SpannedExpr<Tier<Op, NextTier>>>> <op:Op> <r:Box<SpannedExpr<NextTier>>> => ExprKind::BinOp{<>},
    NextTier,
}

SpannedExpr<T>: Expr = {
    <@L> <T> <@R> => Expr::new(<>),
}

SpannedInstr<T>: Instr = {
    <@L> <T> <@R> => Instr::new(<>),
}

Box<T>: Box<T> = <T> => Box::new(<>);
