use crate::ast::Expr;
use crate::ast::BinOp;
use crate::ast::UniOp;
use crate::ast::Item;
use crate::ast::Instr;
use crate::lexer::Tok;
use lalrpop_util::ParseError;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = String;

    enum Tok<'input> {
        "fn" => Tok::Fn,
        "return" => Tok::Return,
        "var" => Tok::Var,
        "for" => Tok::For,
        "in" => Tok::In,
        "if" => Tok::If,
        "else" => Tok::Else,

        "(" => Tok::LParen,
        ")" => Tok::RParen,
        "{" => Tok::LBrace,
        "}" => Tok::RBrace,
        "+" => Tok::Plus,
        "-" => Tok::Minus,
        "*" => Tok::Asterisk,
        "/" => Tok::Slash,
        "&" => Tok::Apersand,
        "%" => Tok::Percent,
        ".." => Tok::DotDot,
        "." => Tok::Dot,
        "==" => Tok::EqualEqual,
        "and" => Tok::And,
        "," => Tok::Comma,
        "=" => Tok::Equal,
        "\n" => Tok::NewLine,
        id => Tok::Id(<&'input str>),
        number => Tok::Number(<&'input str>),
        string => Tok::String(<&'input str>),
    }
}

pub Program = ("\n")* <SeperatedList<Item, "\n"+>>;

Item: Item = {
    "fn" <Id> "(" ")" <Block> => Item::Function(<>),
}
Instr: Instr = {
    "return" <Expr?>  => Instr::Return(<>),
    "var" <Id> "=" <Expr> => Instr::VarInit(<>),
    "for" <Id> "in" <Expr> ".." <Expr> <Block> => Instr::For(<>),
    "if" <Expr> <Block> <("else" "if" <Expr> <Block>)*> <("else" <Block>)?> => Instr::If(<>),
    <Expr> => Instr::Expr(<>),
}

Block: Vec<Instr> = {
    "{" ("\n")+ <(<Instr> "\n"+)*> "}" => <>
}


// Lowest precedence
Expr = Tier<BinOpBoolean, Expr_>;
Expr_ = Tier<BinOpComparison, Expr__>;
Expr__ = Tier<BinOpExpr, Expr___>;
Expr___ = Tier<BinOpFactor, Term>;
// Highest precedence

Exprs: Vec<Expr> = SeperatedList<Expr, ",">;

Term: Expr = {
    Num => Expr::Number(<>),
    UniOp Term => Expr::uni_op(<>),
    <Id> "(" <Exprs> ")" => Expr::Call(<>),
    "(" <Expr> ")",
    Id => Expr::Variable(<>),
    string => Expr::String(<>.to_string()),
}

Num: i32 = {
    number =>? <>.parse::<i32>().map_err(|e| ParseError::User {
            error: e.to_string(),
        })
}
Id: String = {
    id => <>.to_owned()
}

BinOpFactor: BinOp = {
    "*" => BinOp::Mul,
    "/" => BinOp::Div,
    "%" => BinOp::Mod,
}
BinOpExpr: BinOp = {
    "+" => BinOp::Add,
    "-" => BinOp::Sub,
}
BinOpBoolean: BinOp = {
    "and" => BinOp::And,
}
BinOpComparison: BinOp = {
    "==" => BinOp::Eq,
}
UniOp: UniOp = {
    "-" => UniOp::Neg,
    "&" => UniOp::Ref,
    "*" => UniOp::Deref,
}


SeperatedList<T, Sep>: Vec<T> = {
    <mut v:(<T> Sep)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
}

Tier<Op, NextTier> = {
    Tier<Op, NextTier> Op NextTier => Expr::bin_op(<>),
    NextTier,
}
